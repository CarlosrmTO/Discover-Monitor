import os
import logging
import pandas as pd
import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
from fpdf import FPDF
import tempfile
import base64
from pathlib import Path
from typing import Optional, Dict, Any, List, Tuple

# Configuraci칩n del logger
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('app.log')
    ]
)
logger = logging.getLogger(__name__)

# Directorio de datos
DATA_DIR = Path(__file__).parent / "data"
os.makedirs(DATA_DIR, exist_ok=True)

# Configuraci칩n de la p치gina
st.set_page_config(
    page_title="Monitor de Descubrimiento",
    page_icon="游늵",
    layout="wide",
    initial_sidebar_state="expanded"
)

# T칤tulo de la aplicaci칩n
st.title("游늵 Monitor de Contenidos en Discover")
st.markdown("---")

# Inicializar el estado de la sesi칩n para los datos
if 'df' not in st.session_state:
    st.session_state.df = pd.DataFrame()

# Cargar datos iniciales si no hay datos en la sesi칩n
if st.session_state.df.empty:
    st.session_state.df = pd.DataFrame()
    try:
        st.session_state.df = load_data()
    except Exception as e:
        logger.error(f"Error al cargar datos iniciales: {e}")
        st.session_state.df = pd.DataFrame(columns=['title', 'source', 'section', 'published_date', 'url'])

def generate_source_chart(df: pd.DataFrame) -> go.Figure:
    """Genera un gr치fico de barras mostrando art칤culos por fuente.
    
    Args:
        df: DataFrame con los datos de los art칤culos
        
    Returns:
        Objeto Figure de Plotly con el gr치fico
    """
    if df.empty or 'source' not in df.columns:
        return None
        
    source_counts = df['source'].value_counts().reset_index()
    source_counts.columns = ['Fuente', 'Cantidad']
    
    fig = px.bar(
        source_counts, 
        x='Fuente', 
        y='Cantidad',
        color='Fuente',
        title='Total de art칤culos por fuente',
        labels={'Fuente': 'Fuente', 'Cantidad': 'N칰mero de art칤culos'}
    )
    
    return fig

def generate_section_chart(df: pd.DataFrame, top_n: int = 10) -> go.Figure:
    """Genera un gr치fico de barras mostrando las secciones con m치s art칤culos.
    
    Args:
        df: DataFrame con los datos de los art칤culos
        top_n: N칰mero de secciones a mostrar
        
    Returns:
        Objeto Figure de Plotly con el gr치fico
    """
    if df.empty or 'section' not in df.columns:
        return None
    
    section_counts = df['section'].value_counts().head(top_n).reset_index()
    section_counts.columns = ['Secci칩n', 'Cantidad']
    
    fig = px.bar(
        section_counts, 
        x='Cantidad', 
        y='Secci칩n',
        orientation='h',
        title=f'Top {top_n} secciones con m치s art칤culos',
        color='Secci칩n',
        labels={'Secci칩n': 'Secci칩n', 'Cantidad': 'N칰mero de art칤culos'}
    )
    
    return fig

def generate_pdf_report(df: pd.DataFrame, output_path: str) -> None:
    """Genera un informe en PDF con los datos de los art칤culos.
    
    Args:
        df: DataFrame con los datos de los art칤culos
        output_path: Ruta donde guardar el archivo PDF
    """
    if df.empty:
        return
    
    # Crear el objeto PDF
    pdf = FPDF()
    pdf.add_page()
    
    # Configurar fuente y colores
    pdf.set_font('Arial', 'B', 16)
    pdf.cell(0, 10, 'Informe de Art칤culos en Discover', 0, 1, 'C')
    pdf.ln(10)
    
    # Agregar fecha del informe
    pdf.set_font('Arial', '', 12)
    pdf.cell(0, 10, f'Generado el: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}', 0, 1)
    pdf.ln(10)
    
    # Estad칤sticas generales
    pdf.set_font('Arial', 'B', 14)
    pdf.cell(0, 10, 'Estad칤sticas Generales', 0, 1)
    pdf.set_font('Arial', '', 12)
    pdf.cell(0, 10, f'Total de art칤culos: {len(df)}', 0, 1)
    pdf.cell(0, 10, f'Fuentes 칰nicas: {df["source"].nunique() if "source" in df.columns else 0}', 0, 1)
    pdf.cell(0, 10, f'Secciones 칰nicas: {df["section"].nunique() if "section" in df.columns else 0}', 0, 1)
    pdf.ln(10)
    
    # Tabla de art칤culos
    if not df.empty:
        pdf.set_font('Arial', 'B', 14)
        pdf.cell(0, 10, 'Resumen de Art칤culos', 0, 1)
        pdf.set_font('Arial', 'B', 10)
        
        # Encabezados de la tabla
        cols = ['T칤tulo', 'Fuente', 'Secci칩n', 'Fecha']
        col_widths = [80, 30, 30, 30]
        
        # Ajustar anchos si es necesario
        total_width = sum(col_widths)
        page_width = 190  # Ancho de p치gina A4 menos m치rgenes
        if total_width > page_width:
            ratio = page_width / total_width
            col_widths = [int(w * ratio) for w in col_widths]
        
        # Imprimir encabezados
        for i, col in enumerate(cols):
            pdf.cell(col_widths[i], 10, col, 1, 0, 'C')
        pdf.ln()
        
        # Imprimir filas
        pdf.set_font('Arial', '', 8)
        for _, row in df.head(50).iterrows():  # Limitar a 50 filas para no hacer el PDF muy grande
            # T칤tulo (truncar si es muy largo)
            title = str(row.get('title', ''))[:30] + '...' if len(str(row.get('title', ''))) > 30 else str(row.get('title', ''))
            pdf.cell(col_widths[0], 10, title, 1, 0, 'L')
            
            # Fuente
            pdf.cell(col_widths[1], 10, str(row.get('source', ''))[:15], 1, 0, 'C')
            
            # Secci칩n
            pdf.cell(col_widths[2], 10, str(row.get('section', ''))[:15], 1, 0, 'C')
            
            # Fecha
            pub_date = row.get('published_date', '')
            if pd.notna(pub_date) and pub_date:
                if isinstance(pub_date, str):
                    date_str = pub_date.split('T')[0] if 'T' in pub_date else pub_date
                else:
                    date_str = pub_date.strftime('%Y-%m-%d')
            else:
                date_str = 'N/A'
                
            pdf.cell(col_widths[3], 10, date_str, 1, 0, 'C')
            pdf.ln()
    
    # Guardar el PDF
    pdf.output(output_path)
    logger.info(f"Informe PDF guardado en: {output_path}")

def load_data():
    """Carga los datos de los art칤culos desde el archivo CSV."""
    data_file = Path(__file__).parent / "data" / "articles.csv"
    if data_file.exists():
        df = pd.read_csv(data_file, parse_dates=['timestamp'])
        # Asegurarse de que la columna de fecha est칠 en formato datetime
        if 'published_date' in df.columns:
            df['published_date'] = pd.to_datetime(df['published_date'], errors='coerce')
        return df
    return pd.DataFrame()

# Funci칩n para cargar datos si es necesario
def get_data():
    """Obtiene los datos, carg치ndolos si es necesario.
    
    Returns:
        DataFrame con los datos cargados
    """
    if 'df' not in st.session_state or st.session_state.df.empty:
        st.session_state.df = load_data()
    return st.session_state.df

# Sidebar para filtros
st.sidebar.title("Filtros")

# Filtro por fuente
if not st.session_state.df.empty:
    sources = ['Todos'] + sorted(st.session_state.df['source'].dropna().unique().tolist())
    selected_source = st.sidebar.selectbox('Fuente', sources, index=0)
    
    # Aplicar filtro de fuente
    filtered_df = st.session_state.df
    if selected_source != 'Todos':
        filtered_df = filtered_df[filtered_df['source'] == selected_source]

# Filtro por fecha
if not filtered_df.empty and 'published_date' in filtered_df.columns and not filtered_df['published_date'].isna().all():
    min_date = filtered_df['published_date'].min().date()
    max_date = filtered_df['published_date'].max().date()
    
    # Usar un rango de fechas m치s peque침o si es necesario
    date_range = (max_date - min_date).days
    if date_range > 365:  # M치s de un a침o de datos
        default_end = max_date
        default_start = max(default_end - timedelta(days=30), min_date)  # 칔ltimos 30 d칤as
    else:
        default_start = min_date
        default_end = max_date
        
    start_date = st.sidebar.date_input(
        'Fecha de inicio:', 
        value=default_start,
        min_value=min_date, 
        max_value=max_date
    )
    end_date = st.sidebar.date_input(
        'Fecha de fin:', 
        value=default_end,
        min_value=min_date, 
        max_value=max_date
    )
    
    # Asegurarse de que la fecha de inicio sea menor o igual a la fecha de fin
    if start_date > end_date:
        st.sidebar.error('Error: La fecha de inicio debe ser anterior a la fecha de fin')
    else:
        filtered_df = filtered_df[
            (filtered_df['published_date'].dt.date >= start_date) & 
            (filtered_df['published_date'].dt.date <= end_date)
        ]

# Mostrar datos
if filtered_df.empty:
    st.warning("No hay datos disponibles con los filtros seleccionados.")
    
# Mostrar estad칤sticas si hay datos
if not filtered_df.empty:
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Total de art칤culos", len(filtered_df))
    with col2:
        st.metric("Fuentes 칰nicas", filtered_df['source'].nunique())
    with col3:
        st.metric("Secciones 칰nicas", filtered_df['section'].nunique())
    
    # Pesta침as para diferentes vistas
    tab1, tab2, tab3 = st.tabs(["游늵 Resumen", "游닗 Art칤culos", "游늳 An치lisis"])
    
    with tab1:
        st.subheader("Resumen de datos")
        
        # Gr치fico de art칤culos por fuente
        st.markdown("### Art칤culos por fuente")
        source_counts = filtered_df['source'].value_counts().reset_index()
        source_counts.columns = ['Fuente', 'Cantidad']
        
        fig1 = px.bar(
            source_counts, 
            x='Fuente', 
            y='Cantidad',
            color='Fuente',
            title='Total de art칤culos por fuente'
        )
        st.plotly_chart(fig1, use_container_width=True)
        
        # Gr치fico de art칤culos por secci칩n (top 10)
        st.markdown("### Top 10 secciones con m치s art칤culos")
        section_counts = filtered_df['section'].value_counts().head(10).reset_index()
        section_counts.columns = ['Secci칩n', 'Cantidad']
        
        fig2 = px.bar(
            section_counts, 
            x='Cantidad', 
            y='Secci칩n',
            orientation='h',
            title='Top 10 secciones con m치s art칤culos',
            color='Secci칩n'
        )
        st.plotly_chart(fig2, use_container_width=True)
    
    with tab2:
        # Mostrar tabla con los art칤culos
        st.subheader("Lista de art칤culos")
        st.dataframe(
            filtered_df[['title', 'source', 'section', 'published_date']].sort_values('published_date', ascending=False),
            column_config={
                'title': 'T칤tulo',
                'source': 'Fuente',
                'section': 'Secci칩n',
                'published_date': 'Fecha de publicaci칩n'
            },
            hide_index=True,
            use_container_width=True
        )
    
    with tab3:
        st.subheader("An치lisis detallado")
        
        # Gr치fico de art칤culos por secci칩n por fuente
        st.markdown("### Art칤culos por secci칩n por fuente")
        if not filtered_df.empty and 'source' in filtered_df.columns and 'section' in filtered_df.columns:
            source_section = filtered_df.groupby(['source', 'section']).size().reset_index(name='count')
            
            fig3 = px.bar(
                source_section,
                x='source',
                y='count',
                color='section',
                title='Distribuci칩n de art칤culos por secci칩n y fuente',
                labels={'source': 'Fuente', 'count': 'N칰mero de art칤culos', 'section': 'Secci칩n'}
            )
            st.plotly_chart(fig3, use_container_width=True)
        
        # Gr치fico de tendencia temporal
        st.markdown("### Tendencias temporales")
        if not filtered_df.empty and 'published_date' in filtered_df.columns:
            # Agrupar por fecha y fuente
            df_daily = filtered_df.copy()
            df_daily['date'] = df_daily['published_date'].dt.date
            daily_counts = df_daily.groupby(['date', 'source']).size().reset_index(name='count')
            
            fig4 = px.line(
                daily_counts,
                x='date',
                y='count',
                color='source',
                title='Tendencia de publicaciones por d칤a',
                labels={'date': 'Fecha', 'count': 'N칰mero de art칤culos', 'source': 'Fuente'}
            )
            st.plotly_chart(fig4, use_container_width=True)
    
    # Secci칩n de exportaci칩n
    st.sidebar.markdown("---")
    st.sidebar.subheader("Exportar datos")
    
    # Funci칩n para crear un enlace de descarga
    def get_download_link(file_path, file_label):
        with open(file_path, "rb") as f:
            data = f.read()
        b64 = base64.b64encode(data).decode()
        href = f'<a href="data:application/octet-stream;base64,{b64}" download="{os.path.basename(file_path)}">Descargar {file_label}</a>'
        return href
    
    # Exportar a CSV
    if st.sidebar.button("Exportar a CSV"):
        if not filtered_df.empty:
            csv = filtered_df.to_csv(index=False).encode('utf-8')
            st.sidebar.download_button(
                label="Descargar CSV",
                data=csv,
                file_name=f'discover_articles_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv',
                mime='text/csv',
            )
        else:
            st.sidebar.warning("No hay datos para exportar.")
        
    # Exportar a Excel
    if st.sidebar.button("Exportar a Excel"):
        if not filtered_df.empty:
            with tempfile.NamedTemporaryFile(delete=False, suffix='.xlsx') as tmp:
                with pd.ExcelWriter(tmp.name, engine='openpyxl') as writer:
                    filtered_df.to_excel(writer, index=False, sheet_name='Articulos')
                
                with open(tmp.name, 'rb') as f:
                    excel_data = f.read()
                
                st.sidebar.download_button(
                    label="Descargar Excel",
                    data=excel_data,
                    file_name=f'discover_articles_{datetime.now().strftime("%Y%m%d_%H%M%S")}.xlsx',
                    mime='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                )
            
            # Eliminar el archivo temporal
            try:
                os.unlink(tmp.name)
            except Exception as e:
                logger.error(f"Error al eliminar archivo temporal: {e}")
        else:
            st.sidebar.warning("No hay datos para exportar.")
    
    # Exportar a PDF
    if st.sidebar.button("Exportar a PDF"):
        if not filtered_df.empty:
            with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as tmp:
                generate_pdf_report(filtered_df, tmp.name)
                
                with open(tmp.name, 'rb') as f:
                    pdf_data = f.read()
                
                st.sidebar.download_button(
                    label="Descargar PDF",
                    data=pdf_data,
                    file_name=f'discover_report_{datetime.now().strftime("%Y%m%d_%H%M%S")}.pdf',
                    mime='application/pdf',
                )
        # Tabla de art칤culos (solo las primeras 50 filas para no hacer el PDF demasiado grande)
        pdf.set_font("Arial", 'B', 12)
        pdf.cell(200, 10, txt=f"Art칤culos recientes (mostrando {min(50, len(df))} de {len(df)}):", ln=True)
        pdf.ln(5)
        
        # Configurar la tabla
        pdf.set_font("Arial", 'B', 10)
        col_widths = [100, 30, 30, 30]  # Ajustar seg칰n sea necesario
        
        # Encabezados de la tabla
        headers = ['T칤tulo', 'Fuente', 'Secci칩n', 'Fecha']
        for i, header in enumerate(headers):
            pdf.cell(col_widths[i], 10, txt=header, border=1)
        pdf.ln()
        
        # Filas de la tabla
        pdf.set_font("Arial", size=8)
        for _, row in df.head(50).iterrows():
            # Ajustar el texto para que quepa en la celda
            title = row['title'][:40] + '...' if len(str(row['title'])) > 40 else row['title']
            source = str(row['source'])[:15] + '...' if len(str(row['source'])) > 15 else row['source']
            section = str(row['section'])[:15] + '...' if len(str(row['section'])) > 15 else row['section']
            date = str(row['published_date']).split(' ')[0] if 'published_date' in row and pd.notna(row['published_date']) else 'N/A'
            
            pdf.cell(col_widths[0], 10, txt=str(title), border=1)
            pdf.cell(col_widths[1], 10, txt=str(source), border=1)
            pdf.cell(col_widths[2], 10, txt=str(section), border=1)
            pdf.cell(col_widths[3], 10, txt=str(date), border=1)
            pdf.ln()
        
        # Guardar el PDF temporal
        pdf_file = tempfile.NamedTemporaryFile(delete=False, suffix='.pdf')
        pdf.output(pdf_file.name)
        
        # Crear bot칩n de descarga
        with open(pdf_file.name, "rb") as f:
            pdf_data = f.read()
        
        st.sidebar.download_button(
            label="Descargar PDF",
            data=pdf_data,
            file_name=f"discover_report_{datetime.now().strftime('%Y%m%d')}.pdf",
            mime="application/pdf"
        )

# Mensaje de ayuda si no hay datos
# Mostrar opci칩n para ejecutar el scraper si no hay datos
if st.session_state.df.empty:
    st.info("No se encontraron datos. Ejecuta el script de scraping primero para generar datos.")
    if st.button("Ejecutar Scraper"):
        with st.spinner("Ejecutando scraper..."):
            try:
                import subprocess
                result = subprocess.run(['python', 'main.py'], capture_output=True, text=True)
                if result.returncode == 0:
                    st.success("춰Scraper ejecutado exitosamente!")
                    st.session_state.df = load_data()
                    st.rerun()
                else:
                    st.error(f"Error al ejecutar el scraper: {result.stderr}")
            except Exception as e:
                st.error(f"Error inesperado: {str(e)}")
                logger.error(f"Error al ejecutar scraper: {str(e)}")
